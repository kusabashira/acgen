#!/usr/bin/env perl
use strict;
use warnings;
use utf8;
use YAML::Syck ();
use Getopt::Long qw(:config posix_default no_ignore_case bundling);

my $generator = +{
  bash => sub {
    my $conf = shift;
    my $name = $conf->{name};
    my $opts = [];
    for my $flag (@{$conf->{flags}}) {
      next unless defined $flag->{long};
      my $opt = '--' . $flag->{long} . (defined $flag->{arg}? '=': '');
      push @$opts, $opt;
    }
    return <<__BASH__;
_$name()
{
  local cur="\${COMP_WORDS[COMP_CWORD]}"
  local opts="
@{[join "\n", map { "    $_" } @$opts]}
  "
  case "\$cur" in
    -*)
      COMPREPLY=( \$(compgen -W "\$opts" -- "\$cur") )
      ;;
    *)
      _filedir
      ;;
  esac
  [[ \${COMPREPLY[0]} == *= ]] && compopt -o nospace
}
complete -F _$name $name
__BASH__
  },

  zsh => sub {
    my $conf = shift;
    my $name = $conf->{name};
    my $propaties = [];
    for my $flag (@{$conf->{flags}}) {
      my $opts = [];
      push @$opts, "-$flag->{short}" if defined $flag->{short};
      push @$opts, "--$flag->{long}" if defined $flag->{long};
      my $exclusive = join(' ', @$opts);
      my $options = ($#$opts < 1)? $opts->[0]: '{' . join(',', @$opts) . '}';
      my $description = $flag->{description};
      $description =~ s/\\/\\\\/g;
      $description =~ s/'/'"'"'/g;
      my $arguments = (defined $flag->{arg}? ":$flag->{arg}": '');
      push @$propaties, "'($exclusive)'$options'[$description]$arguments'";
    }
    return <<__ZSH__;
#compdef $name
_arguments \
@{[join "\n", map { "    $_ \\" } @$propaties]}
    '*:input files:_files'
__ZSH__
  },

  fish => sub {
    my $conf = shift;
    my $name = $conf->{name};
    my $statements = [];
    for my $flag (@{$conf->{flags}}) {
      my $complete = [];
      push @$complete, "complete", "-c", $name;
      push @$complete, "-s", $flag->{short} if defined $flag->{short};
      push @$complete, "-l", $flag->{long} if defined $flag->{long};
      my $description = $flag->{description};
      $description =~ s/'/\\'/g;
      $description =~ s/^|$/'/g;
      push @$complete, "-d", $description;
      push @$statements, join(' ', @$complete) . "\n";
    }
    return join '', @$statements;
  },

  yash => sub {
    my $conf = shift;
    my $name = $conf->{name};
    my $opts = [];
    for my $flag (@{$conf->{flags}}) {
      my $opt = [];
      if (defined $flag->{short}) {
        push @$opt, $flag->{short} . (defined $flag->{arg}? ':': '');
      }
      if (defined $flag->{long}) {
        push @$opt, $flag->{long} . (defined $flag->{arg}? ':': '');
      }
      my $description = $flag->{description};
      $description =~ s/\\/\\\\/g;
      $description =~ s/"/\\"/g;
      push @$opts, "\"@{[join ' ', @$opt]}; $description\"";
    }
    return <<__YASH__;
function completion/$name {
	typeset OPTIONS ARGOPT PREFIX
	OPTIONS=(
@{[join "\n", map { "\t$_" } @$opts]}
	)
	command -f completion//parseoptions -es
	case \$ARGOPT in
	(-)
		command -f completion//completeoptions
		;;
	(*)
		complete -f
		;;
	esac
}
# vim: set ft=sh ts=8 sts=8 sw=8 noet:
__YASH__
  },
};

Getopt::Long::GetOptions(
  'type|t=s' => \my $type,
) or exit 2;

die "no input src" unless $#ARGV >= 0;
die "no specify completion type" unless defined $type;
die "$type: is not supported" unless defined $generator->{$type};

my $src = shift;
my $conf = YAML::Syck::LoadFile($src);
print $generator->{$type}($conf);
